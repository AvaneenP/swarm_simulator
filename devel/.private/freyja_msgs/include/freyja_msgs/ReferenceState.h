// Generated by gencpp from file freyja_msgs/ReferenceState.msg
// DO NOT EDIT!


#ifndef FREYJA_MSGS_MESSAGE_REFERENCESTATE_H
#define FREYJA_MSGS_MESSAGE_REFERENCESTATE_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <std_msgs/Header.h>

namespace freyja_msgs
{
template <class ContainerAllocator>
struct ReferenceState_
{
  typedef ReferenceState_<ContainerAllocator> Type;

  ReferenceState_()
    : header()
    , pn(0.0)
    , pe(0.0)
    , pd(0.0)
    , vn(0.0)
    , ve(0.0)
    , vd(0.0)
    , yaw(0.0)
    , an(0.0)
    , ae(0.0)
    , ad(0.0)  {
    }
  ReferenceState_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , pn(0.0)
    , pe(0.0)
    , pd(0.0)
    , vn(0.0)
    , ve(0.0)
    , vd(0.0)
    , yaw(0.0)
    , an(0.0)
    , ae(0.0)
    , ad(0.0)  {
  (void)_alloc;
    }



   typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
  _header_type header;

   typedef double _pn_type;
  _pn_type pn;

   typedef double _pe_type;
  _pe_type pe;

   typedef double _pd_type;
  _pd_type pd;

   typedef double _vn_type;
  _vn_type vn;

   typedef double _ve_type;
  _ve_type ve;

   typedef double _vd_type;
  _vd_type vd;

   typedef double _yaw_type;
  _yaw_type yaw;

   typedef double _an_type;
  _an_type an;

   typedef double _ae_type;
  _ae_type ae;

   typedef double _ad_type;
  _ad_type ad;





  typedef boost::shared_ptr< ::freyja_msgs::ReferenceState_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::freyja_msgs::ReferenceState_<ContainerAllocator> const> ConstPtr;

}; // struct ReferenceState_

typedef ::freyja_msgs::ReferenceState_<std::allocator<void> > ReferenceState;

typedef boost::shared_ptr< ::freyja_msgs::ReferenceState > ReferenceStatePtr;
typedef boost::shared_ptr< ::freyja_msgs::ReferenceState const> ReferenceStateConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::freyja_msgs::ReferenceState_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::freyja_msgs::ReferenceState_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::freyja_msgs::ReferenceState_<ContainerAllocator1> & lhs, const ::freyja_msgs::ReferenceState_<ContainerAllocator2> & rhs)
{
  return lhs.header == rhs.header &&
    lhs.pn == rhs.pn &&
    lhs.pe == rhs.pe &&
    lhs.pd == rhs.pd &&
    lhs.vn == rhs.vn &&
    lhs.ve == rhs.ve &&
    lhs.vd == rhs.vd &&
    lhs.yaw == rhs.yaw &&
    lhs.an == rhs.an &&
    lhs.ae == rhs.ae &&
    lhs.ad == rhs.ad;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::freyja_msgs::ReferenceState_<ContainerAllocator1> & lhs, const ::freyja_msgs::ReferenceState_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace freyja_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsFixedSize< ::freyja_msgs::ReferenceState_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::freyja_msgs::ReferenceState_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct IsMessage< ::freyja_msgs::ReferenceState_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::freyja_msgs::ReferenceState_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::freyja_msgs::ReferenceState_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::freyja_msgs::ReferenceState_<ContainerAllocator> const>
  : TrueType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::freyja_msgs::ReferenceState_<ContainerAllocator> >
{
  static const char* value()
  {
    return "01a1c8686cad14cd024a0eabf82f6a91";
  }

  static const char* value(const ::freyja_msgs::ReferenceState_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x01a1c8686cad14cdULL;
  static const uint64_t static_value2 = 0x024a0eabf82f6a91ULL;
};

template<class ContainerAllocator>
struct DataType< ::freyja_msgs::ReferenceState_<ContainerAllocator> >
{
  static const char* value()
  {
    return "freyja_msgs/ReferenceState";
  }

  static const char* value(const ::freyja_msgs::ReferenceState_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::freyja_msgs::ReferenceState_<ContainerAllocator> >
{
  static const char* value()
  {
    return "# Reference 10-element state for the controller to follow.\n"
"Header header\n"
"\n"
"float64 pn\n"
"float64 pe\n"
"float64 pd\n"
"float64 vn\n"
"float64 ve\n"
"float64 vd\n"
"float64 yaw\n"
"float64 an\n"
"float64 ae\n"
"float64 ad\n"
"\n"
"================================================================================\n"
"MSG: std_msgs/Header\n"
"# Standard metadata for higher-level stamped data types.\n"
"# This is generally used to communicate timestamped data \n"
"# in a particular coordinate frame.\n"
"# \n"
"# sequence ID: consecutively increasing ID \n"
"uint32 seq\n"
"#Two-integer timestamp that is expressed as:\n"
"# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n"
"# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n"
"# time-handling sugar is provided by the client library\n"
"time stamp\n"
"#Frame this data is associated with\n"
"string frame_id\n"
;
  }

  static const char* value(const ::freyja_msgs::ReferenceState_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::freyja_msgs::ReferenceState_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.pn);
      stream.next(m.pe);
      stream.next(m.pd);
      stream.next(m.vn);
      stream.next(m.ve);
      stream.next(m.vd);
      stream.next(m.yaw);
      stream.next(m.an);
      stream.next(m.ae);
      stream.next(m.ad);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct ReferenceState_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::freyja_msgs::ReferenceState_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::freyja_msgs::ReferenceState_<ContainerAllocator>& v)
  {
    s << indent << "header: ";
    s << std::endl;
    Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "pn: ";
    Printer<double>::stream(s, indent + "  ", v.pn);
    s << indent << "pe: ";
    Printer<double>::stream(s, indent + "  ", v.pe);
    s << indent << "pd: ";
    Printer<double>::stream(s, indent + "  ", v.pd);
    s << indent << "vn: ";
    Printer<double>::stream(s, indent + "  ", v.vn);
    s << indent << "ve: ";
    Printer<double>::stream(s, indent + "  ", v.ve);
    s << indent << "vd: ";
    Printer<double>::stream(s, indent + "  ", v.vd);
    s << indent << "yaw: ";
    Printer<double>::stream(s, indent + "  ", v.yaw);
    s << indent << "an: ";
    Printer<double>::stream(s, indent + "  ", v.an);
    s << indent << "ae: ";
    Printer<double>::stream(s, indent + "  ", v.ae);
    s << indent << "ad: ";
    Printer<double>::stream(s, indent + "  ", v.ad);
  }
};

} // namespace message_operations
} // namespace ros

#endif // FREYJA_MSGS_MESSAGE_REFERENCESTATE_H
