// Generated by gencpp from file freyja_msgs/AsctecData.msg
// DO NOT EDIT!


#ifndef FREYJA_MSGS_MESSAGE_ASCTECDATA_H
#define FREYJA_MSGS_MESSAGE_ASCTECDATA_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <std_msgs/Header.h>

namespace freyja_msgs
{
template <class ContainerAllocator>
struct AsctecData_
{
  typedef AsctecData_<ContainerAllocator> Type;

  AsctecData_()
    : header()
    , lat(0)
    , lon(0)
    , best_lat(0)
    , best_lon(0)
    , hgt(0)
    , sp_x(0)
    , sp_y(0)
    , best_sp_x(0)
    , best_sp_y(0)
    , best_sp_z(0)
    , heading_angle(0)
    , pitch_angle(0)
    , roll_angle(0)
    , yaw_angle(0)
    , pitch_anglevel(0)
    , roll_anglevel(0)
    , yaw_anglevel(0)
    , accx(0)
    , accy(0)
    , accz(0)
    , motor1rpm(0)
    , motor2rpm(0)
    , motor3rpm(0)
    , motor4rpm(0)
    , motor5rpm(0)
    , motor6rpm(0)  {
    }
  AsctecData_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , lat(0)
    , lon(0)
    , best_lat(0)
    , best_lon(0)
    , hgt(0)
    , sp_x(0)
    , sp_y(0)
    , best_sp_x(0)
    , best_sp_y(0)
    , best_sp_z(0)
    , heading_angle(0)
    , pitch_angle(0)
    , roll_angle(0)
    , yaw_angle(0)
    , pitch_anglevel(0)
    , roll_anglevel(0)
    , yaw_anglevel(0)
    , accx(0)
    , accy(0)
    , accz(0)
    , motor1rpm(0)
    , motor2rpm(0)
    , motor3rpm(0)
    , motor4rpm(0)
    , motor5rpm(0)
    , motor6rpm(0)  {
  (void)_alloc;
    }



   typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
  _header_type header;

   typedef int64_t _lat_type;
  _lat_type lat;

   typedef int64_t _lon_type;
  _lon_type lon;

   typedef int64_t _best_lat_type;
  _best_lat_type best_lat;

   typedef int64_t _best_lon_type;
  _best_lon_type best_lon;

   typedef int64_t _hgt_type;
  _hgt_type hgt;

   typedef int64_t _sp_x_type;
  _sp_x_type sp_x;

   typedef int64_t _sp_y_type;
  _sp_y_type sp_y;

   typedef int64_t _best_sp_x_type;
  _best_sp_x_type best_sp_x;

   typedef int64_t _best_sp_y_type;
  _best_sp_y_type best_sp_y;

   typedef int64_t _best_sp_z_type;
  _best_sp_z_type best_sp_z;

   typedef int64_t _heading_angle_type;
  _heading_angle_type heading_angle;

   typedef int64_t _pitch_angle_type;
  _pitch_angle_type pitch_angle;

   typedef int64_t _roll_angle_type;
  _roll_angle_type roll_angle;

   typedef int64_t _yaw_angle_type;
  _yaw_angle_type yaw_angle;

   typedef int64_t _pitch_anglevel_type;
  _pitch_anglevel_type pitch_anglevel;

   typedef int64_t _roll_anglevel_type;
  _roll_anglevel_type roll_anglevel;

   typedef int64_t _yaw_anglevel_type;
  _yaw_anglevel_type yaw_anglevel;

   typedef int64_t _accx_type;
  _accx_type accx;

   typedef int64_t _accy_type;
  _accy_type accy;

   typedef int64_t _accz_type;
  _accz_type accz;

   typedef uint8_t _motor1rpm_type;
  _motor1rpm_type motor1rpm;

   typedef uint8_t _motor2rpm_type;
  _motor2rpm_type motor2rpm;

   typedef uint8_t _motor3rpm_type;
  _motor3rpm_type motor3rpm;

   typedef uint8_t _motor4rpm_type;
  _motor4rpm_type motor4rpm;

   typedef uint8_t _motor5rpm_type;
  _motor5rpm_type motor5rpm;

   typedef uint8_t _motor6rpm_type;
  _motor6rpm_type motor6rpm;





  typedef boost::shared_ptr< ::freyja_msgs::AsctecData_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::freyja_msgs::AsctecData_<ContainerAllocator> const> ConstPtr;

}; // struct AsctecData_

typedef ::freyja_msgs::AsctecData_<std::allocator<void> > AsctecData;

typedef boost::shared_ptr< ::freyja_msgs::AsctecData > AsctecDataPtr;
typedef boost::shared_ptr< ::freyja_msgs::AsctecData const> AsctecDataConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::freyja_msgs::AsctecData_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::freyja_msgs::AsctecData_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::freyja_msgs::AsctecData_<ContainerAllocator1> & lhs, const ::freyja_msgs::AsctecData_<ContainerAllocator2> & rhs)
{
  return lhs.header == rhs.header &&
    lhs.lat == rhs.lat &&
    lhs.lon == rhs.lon &&
    lhs.best_lat == rhs.best_lat &&
    lhs.best_lon == rhs.best_lon &&
    lhs.hgt == rhs.hgt &&
    lhs.sp_x == rhs.sp_x &&
    lhs.sp_y == rhs.sp_y &&
    lhs.best_sp_x == rhs.best_sp_x &&
    lhs.best_sp_y == rhs.best_sp_y &&
    lhs.best_sp_z == rhs.best_sp_z &&
    lhs.heading_angle == rhs.heading_angle &&
    lhs.pitch_angle == rhs.pitch_angle &&
    lhs.roll_angle == rhs.roll_angle &&
    lhs.yaw_angle == rhs.yaw_angle &&
    lhs.pitch_anglevel == rhs.pitch_anglevel &&
    lhs.roll_anglevel == rhs.roll_anglevel &&
    lhs.yaw_anglevel == rhs.yaw_anglevel &&
    lhs.accx == rhs.accx &&
    lhs.accy == rhs.accy &&
    lhs.accz == rhs.accz &&
    lhs.motor1rpm == rhs.motor1rpm &&
    lhs.motor2rpm == rhs.motor2rpm &&
    lhs.motor3rpm == rhs.motor3rpm &&
    lhs.motor4rpm == rhs.motor4rpm &&
    lhs.motor5rpm == rhs.motor5rpm &&
    lhs.motor6rpm == rhs.motor6rpm;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::freyja_msgs::AsctecData_<ContainerAllocator1> & lhs, const ::freyja_msgs::AsctecData_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace freyja_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsFixedSize< ::freyja_msgs::AsctecData_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::freyja_msgs::AsctecData_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct IsMessage< ::freyja_msgs::AsctecData_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::freyja_msgs::AsctecData_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::freyja_msgs::AsctecData_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::freyja_msgs::AsctecData_<ContainerAllocator> const>
  : TrueType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::freyja_msgs::AsctecData_<ContainerAllocator> >
{
  static const char* value()
  {
    return "8ad7a94e1bacdc1e59233f1b26a5c94c";
  }

  static const char* value(const ::freyja_msgs::AsctecData_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x8ad7a94e1bacdc1eULL;
  static const uint64_t static_value2 = 0x59233f1b26a5c94cULL;
};

template<class ContainerAllocator>
struct DataType< ::freyja_msgs::AsctecData_<ContainerAllocator> >
{
  static const char* value()
  {
    return "freyja_msgs/AsctecData";
  }

  static const char* value(const ::freyja_msgs::AsctecData_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::freyja_msgs::AsctecData_<ContainerAllocator> >
{
  static const char* value()
  {
    return "Header header\n"
"\n"
"int64 lat\n"
"int64 lon\n"
"int64 best_lat\n"
"int64 best_lon\n"
"\n"
"int64 hgt \n"
"  \n"
"int64 sp_x\n"
"int64 sp_y\n"
"int64 best_sp_x\n"
"int64 best_sp_y\n"
"int64 best_sp_z\n"
"  \n"
"int64 heading_angle\n"
"\n"
"int64 pitch_angle\n"
"int64 roll_angle\n"
"int64 yaw_angle\n"
"int64 pitch_anglevel\n"
"int64 roll_anglevel\n"
"int64 yaw_anglevel\n"
"\n"
"int64 accx\n"
"int64 accy\n"
"int64 accz\n"
"\n"
"uint8 motor1rpm\n"
"uint8 motor2rpm\n"
"uint8 motor3rpm\n"
"uint8 motor4rpm\n"
"uint8 motor5rpm\n"
"uint8 motor6rpm\n"
"\n"
"================================================================================\n"
"MSG: std_msgs/Header\n"
"# Standard metadata for higher-level stamped data types.\n"
"# This is generally used to communicate timestamped data \n"
"# in a particular coordinate frame.\n"
"# \n"
"# sequence ID: consecutively increasing ID \n"
"uint32 seq\n"
"#Two-integer timestamp that is expressed as:\n"
"# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n"
"# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n"
"# time-handling sugar is provided by the client library\n"
"time stamp\n"
"#Frame this data is associated with\n"
"string frame_id\n"
;
  }

  static const char* value(const ::freyja_msgs::AsctecData_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::freyja_msgs::AsctecData_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.lat);
      stream.next(m.lon);
      stream.next(m.best_lat);
      stream.next(m.best_lon);
      stream.next(m.hgt);
      stream.next(m.sp_x);
      stream.next(m.sp_y);
      stream.next(m.best_sp_x);
      stream.next(m.best_sp_y);
      stream.next(m.best_sp_z);
      stream.next(m.heading_angle);
      stream.next(m.pitch_angle);
      stream.next(m.roll_angle);
      stream.next(m.yaw_angle);
      stream.next(m.pitch_anglevel);
      stream.next(m.roll_anglevel);
      stream.next(m.yaw_anglevel);
      stream.next(m.accx);
      stream.next(m.accy);
      stream.next(m.accz);
      stream.next(m.motor1rpm);
      stream.next(m.motor2rpm);
      stream.next(m.motor3rpm);
      stream.next(m.motor4rpm);
      stream.next(m.motor5rpm);
      stream.next(m.motor6rpm);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct AsctecData_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::freyja_msgs::AsctecData_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::freyja_msgs::AsctecData_<ContainerAllocator>& v)
  {
    s << indent << "header: ";
    s << std::endl;
    Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "lat: ";
    Printer<int64_t>::stream(s, indent + "  ", v.lat);
    s << indent << "lon: ";
    Printer<int64_t>::stream(s, indent + "  ", v.lon);
    s << indent << "best_lat: ";
    Printer<int64_t>::stream(s, indent + "  ", v.best_lat);
    s << indent << "best_lon: ";
    Printer<int64_t>::stream(s, indent + "  ", v.best_lon);
    s << indent << "hgt: ";
    Printer<int64_t>::stream(s, indent + "  ", v.hgt);
    s << indent << "sp_x: ";
    Printer<int64_t>::stream(s, indent + "  ", v.sp_x);
    s << indent << "sp_y: ";
    Printer<int64_t>::stream(s, indent + "  ", v.sp_y);
    s << indent << "best_sp_x: ";
    Printer<int64_t>::stream(s, indent + "  ", v.best_sp_x);
    s << indent << "best_sp_y: ";
    Printer<int64_t>::stream(s, indent + "  ", v.best_sp_y);
    s << indent << "best_sp_z: ";
    Printer<int64_t>::stream(s, indent + "  ", v.best_sp_z);
    s << indent << "heading_angle: ";
    Printer<int64_t>::stream(s, indent + "  ", v.heading_angle);
    s << indent << "pitch_angle: ";
    Printer<int64_t>::stream(s, indent + "  ", v.pitch_angle);
    s << indent << "roll_angle: ";
    Printer<int64_t>::stream(s, indent + "  ", v.roll_angle);
    s << indent << "yaw_angle: ";
    Printer<int64_t>::stream(s, indent + "  ", v.yaw_angle);
    s << indent << "pitch_anglevel: ";
    Printer<int64_t>::stream(s, indent + "  ", v.pitch_anglevel);
    s << indent << "roll_anglevel: ";
    Printer<int64_t>::stream(s, indent + "  ", v.roll_anglevel);
    s << indent << "yaw_anglevel: ";
    Printer<int64_t>::stream(s, indent + "  ", v.yaw_anglevel);
    s << indent << "accx: ";
    Printer<int64_t>::stream(s, indent + "  ", v.accx);
    s << indent << "accy: ";
    Printer<int64_t>::stream(s, indent + "  ", v.accy);
    s << indent << "accz: ";
    Printer<int64_t>::stream(s, indent + "  ", v.accz);
    s << indent << "motor1rpm: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.motor1rpm);
    s << indent << "motor2rpm: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.motor2rpm);
    s << indent << "motor3rpm: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.motor3rpm);
    s << indent << "motor4rpm: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.motor4rpm);
    s << indent << "motor5rpm: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.motor5rpm);
    s << indent << "motor6rpm: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.motor6rpm);
  }
};

} // namespace message_operations
} // namespace ros

#endif // FREYJA_MSGS_MESSAGE_ASCTECDATA_H
